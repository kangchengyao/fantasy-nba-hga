import pandas as pd
import random
import scipy.stats as stats
import matplotlib.pyplot as plt
import numpy as np
import time
fitness_cache = {}  # å…¨åŸŸå¿«å–å­—å…¸
# è®€å–çƒå“¡æ•¸æ“š
player_data = pd.read_csv("sportsref_final.csv")


# ç¢ºä¿æ•¸æ“šé¡å‹æ­£ç¢ºï¼Œä¸¦å°‡æ¶‰åŠè¨ˆç®—çš„æ•¸æ“šæ¬„ä½è½‰ç‚ºæ•¸å­—é¡å‹
numeric_columns = ['PTS', 'AST', 'STL', 'BLK', 'TOV', 'FGA', 'FG', 'FTA', 'FT', '3P', 'ORB', 'DRB', 'PF']
for col in numeric_columns:
    player_data[col] = pd.to_numeric(player_data[col], errors='coerce').fillna(0)

# è¨­å®šçƒéšŠä½ç½®éœ€æ±‚
positions_required = ['PG', 'SG', 'G', 'G', 'SF', 'PF', 'F', 'F', 'C', 'C', 'Util', 'Util', 'BN', 'BN', 'BN', 'IL', 'IL+']
target_players = {
    "james harden", "shai gilgeous-alexander", "anthony edwards", "trae young",
    "cade cunningham","jayson tatum", "giannis antetokounmpo", "karl-anthony towns",
    "lebron james","nikola jokic" 
}
# è¨­å®šFantasyè¨ˆåˆ†ç³»çµ±
scoring_system = {
    'FGA': -0.9,
    'FG': 2,  # å‘½ä¸­æ¬¡æ•¸
    'FTA': -1.5,
    'FT': 2,  # ç½°çƒå‘½ä¸­æ¬¡æ•¸
    '3P': 1.75,  # ä¸‰åˆ†å‘½ä¸­æ¬¡æ•¸
    'PTS': 0.75,  # å¾—åˆ†
    'OREB': 1.5,  # é€²æ”»ç±ƒæ¿
    'DRB': 1,     # é˜²å®ˆç±ƒæ¿
    'AST': 1.5,   # åŠ©æ”»
    'STL': 3,     # æŠ„æˆª
    'BLK': 3.5,   # é˜»æ”»
    'TOV': -1,    # å¤±èª¤
    'PF': -0.25   # å€‹äººçŠ¯è¦
}
# è¨ˆç®—æŸé …æ•¸æ“šé”åˆ° 10 çš„æ¦‚ç‡
def calculate_probability(mean, std_dev):
    # ä½¿ç”¨æ­£æ…‹åˆ†å¸ƒè¨ˆç®— P(Stat â‰¥ 10)
    if std_dev == 0:  # é˜²æ­¢æ¨™æº–å·®ç‚º 0
        return 1.0 if mean >= 10 else 0.0
    return 1 - stats.norm.cdf(10, loc=mean, scale=std_dev)
# æ¨ä¼°é›™åå’Œå¤§ä¸‰å…ƒçš„å¹³å‡æ¬¡æ•¸
def estimate_double_triple(player_stats):
    total_games = 82  # ç›´æ¥å–çƒéšŠçš„ç¸½å‡ºè³½å ´æ¬¡
    mean_pts = player_stats['PTS']
    mean_reb = player_stats['ORB'] + player_stats['DRB']
    mean_ast = player_stats['AST']
    mean_stl = player_stats['STL']
    mean_blk = player_stats['BLK']

    # å‡è¨­æ¨™æº–å·®ç‚ºå¹³å‡å€¼çš„ 10%ï¼ˆæ ¹æ“šçœŸå¯¦æ•¸æ“šå¯ä»¥èª¿æ•´ï¼‰
    std_dev_pts = mean_pts * 0.15
    std_dev_reb = mean_reb * 0.15
    std_dev_ast = mean_ast * 0.20
    std_dev_stl = mean_stl * 0.15
    std_dev_blk = mean_blk * 0.15

    # è¨ˆç®—æ¯é …æ•¸æ“šé”åˆ° 10 çš„æ¦‚ç‡
    p_pts = calculate_probability(mean_pts, std_dev_pts)
    p_reb = calculate_probability(mean_reb, std_dev_reb)
    p_ast = calculate_probability(mean_ast, std_dev_ast)
    p_stl = calculate_probability(mean_stl, std_dev_stl)
    p_blk = calculate_probability(mean_blk, std_dev_blk)

    # é›™åï¼šå…©é …æ•¸æ“š â‰¥ 10 çš„æ¦‚ç‡ï¼ˆPTS + REB æˆ– REB + AST ç­‰ï¼‰
    double_double_probability = (
        p_pts * p_reb +
        p_pts * p_ast +
        p_reb * p_ast
    )

    # å¤§ä¸‰å…ƒï¼šä¸‰é …æ•¸æ“š â‰¥ 10 çš„æ¦‚ç‡ï¼ˆPTS + REB + AST ç­‰ï¼‰
    triple_double_probability = (
        p_pts * p_reb * p_ast +
        p_reb * p_ast * p_blk +
        p_pts * p_ast * p_blk
    )

    # è¿”å›å¹³å‡æ¬¡æ•¸ï¼ˆç¸½æ¬¡æ•¸é™¤ä»¥å ´æ¬¡ï¼‰
    average_double_double = double_double_probability
    average_triple_double = triple_double_probability

    return average_double_double, average_triple_double

def fitness_function(team):
    total_score = 0
    position_penalty = 0
    selected_players = []
    seen_players = set()

    for i, player_id in enumerate(team):
        position = positions_required[i]

        if player_id in seen_players:
            continue

        # æª¢æŸ¥å¿«å–
        if player_id in fitness_cache:
            player_score, adjusted_score, injury_impact, no_injury_score, player_stats = fitness_cache[player_id]
        else:
            player_stats = player_data[player_data['Rk'] == player_id]
            if player_stats.empty:
                continue

            player_stats = player_stats.iloc[0]

            # åŸºæœ¬åˆ†æ•¸è¨ˆç®—
            player_score = (
                player_stats['FGA'] * scoring_system['FGA'] +
                player_stats['FG'] * scoring_system['FG'] +
                player_stats['FTA'] * scoring_system['FTA'] +
                player_stats['FT'] * scoring_system['FT'] +
                player_stats['3P'] * scoring_system['3P'] +
                player_stats['PTS'] * scoring_system['PTS'] +
                player_stats['ORB'] * scoring_system['OREB'] +
                player_stats['DRB'] * scoring_system['DRB'] +
                player_stats['AST'] * scoring_system['AST'] +
                player_stats['STL'] * scoring_system['STL'] +
                player_stats['BLK'] * scoring_system['BLK'] +
                player_stats['TOV'] * scoring_system['TOV'] +
                player_stats['PF'] * scoring_system['PF']
            )

            # é›™åèˆ‡å¤§ä¸‰å…ƒé¡å¤–åˆ†æ•¸
            average_double_double, average_triple_double = estimate_double_triple(player_stats)
            player_score += average_double_double * 2.5
            player_score += average_triple_double * 5

            # å‚·ç—…å› ç´ èª¿æ•´åˆ†æ•¸
            team_total_games = 82
            games_played = pd.to_numeric(player_stats['G'], errors='coerce')
            injury_impact = games_played / team_total_games if team_total_games > 0 else 0
            adjusted_score = player_score * injury_impact
            no_injury_score = player_score

            # å­˜å…¥å¿«å–
            fitness_cache[player_id] = (player_score, adjusted_score, injury_impact, no_injury_score, player_stats)

        # æª¢æŸ¥ä½ç½®é©åˆåº¦
        if position not in player_stats['Pos'].split('-'):
            position_penalty += 5

        total_score += adjusted_score
        selected_players.append((player_stats['Player'], adjusted_score, player_stats['Pos'], injury_impact, no_injury_score))
        seen_players.add(player_id)

    return total_score - position_penalty, selected_players


# åˆå§‹åŒ–ç¨®ç¾¤
def initialize_population():
    population = []
    for _ in range(600):  # ç¨®ç¾¤å¤§å°
        team = []
        selected_players = set()
        for position in positions_required:
            # å„ªå…ˆé¸æ“‡å¾—åˆ†èƒ½åŠ›æ’åå‰ 50% çš„çƒå“¡
            candidates_pts = player_data[player_data['Pos'].str.contains(position, na=False)].sort_values('PTS', ascending=False)['Rk'].tolist()
            candidates_ast = player_data[player_data['Pos'].str.contains(position, na=False)].sort_values('AST', ascending=False)['Rk'].tolist()
            candidates_reb = player_data[player_data['Pos'].str.contains(position, na=False)].sort_values('ORB', ascending=False)['Rk'].tolist()
            # åˆä½µå¤šå€‹ç‰¹æ€§å€™é¸äººåˆ—è¡¨ï¼Œé¿å…é‡è¤‡
            candidates = list(set(candidates_pts[:30] + candidates_ast[:30] + candidates_reb[:30]))
            candidates = [player for player in candidates if player not in selected_players]
            if candidates:
                chosen_player = random.choice(candidates)
                team.append(chosen_player)
                selected_players.add(chosen_player)
        population.append(team)
    return population

# å‚·ç—…å½±éŸ¿åˆ†æå¯è¦–åŒ–
def visualize_injury_impact(selected_players):
    players = [p[0] for p in selected_players]
    games_played_ratios = [p[3] for p in selected_players]
    adjusted_scores = [p[1] for p in selected_players]
    no_injury_scores = [p[4] for p in selected_players]  # å–å‡º No Injury Score

    # å°‡ Games Played Ratio èª¿æ•´åˆ°èˆ‡ Adjusted Score ç›¸åŒçš„æ•¸å€¼ç¯„åœ
    games_played_ratios_scaled = [x * 100 for x in games_played_ratios]

    # è¨­å®šæŸ±ç‹€åœ–çš„å¯¬åº¦
    bar_width = 0.25
    index = np.arange(len(players))  # è¨­å®š x è»¸ä½ç½®

    # ç¹ªè£½åœ–è¡¨
    plt.figure(figsize=(16, 7))

    plt.bar(index - bar_width, no_injury_scores, width=bar_width, label='No Injury Score', color='black')
    plt.bar(index, adjusted_scores, width=bar_width, label='Adjusted Score', color='purple')
    plt.bar(index + bar_width, games_played_ratios_scaled, width=bar_width, label='Games Played Ratio (Scaled)', color='orange')

    # èª¿æ•´ x è»¸æ¨™ç±¤
    plt.xlabel('Player')
    plt.ylabel('Impact / Score')
    plt.title('Injury Impact on Player Scores (With No Injury Score)')
    plt.xticks(index, players, rotation=45, ha='right')

    plt.legend()
    plt.tight_layout()
    plt.show()


# è¨ˆç®—å‚·ç—…å½±éŸ¿
def calculate_injury_impact(player_stats, player_score):
    games_played = player_stats.get('G', 0)
    adjusted_score = player_score * (games_played / 82) if games_played > 0 else 0
    injury_impact = games_played / 82 if games_played > 0 else 0
    return adjusted_score, injury_impact

# äº¤å‰æ“ä½œ
def crossover(parent1, parent2):
    crossover_point = random.randint(1, len(parent1) - 2)  # é¿å…åœ¨é¦–å°¾é€²è¡Œäº¤å‰
    child1 = parent1[:crossover_point] + parent2[crossover_point:]
    child2 = parent2[:crossover_point] + parent1[crossover_point:]

    # ç§»é™¤å­ä»£ä¸­çš„é‡è¤‡çƒå“¡
    child1 = repair_duplicates(child1)
    child2 = repair_duplicates(child2)

    return child1, child2

def repair_duplicates(team):
    seen = set()
    new_team = []
    for position, player_id in zip(positions_required, team):
        if player_id not in seen:
            new_team.append(player_id)
            seen.add(player_id)
        else:
            # æ›¿æ›ç‚ºé©æ‡‰åº¦æœ€é«˜ä¸”ç¬¦åˆå¤šä½ç½®éœ€æ±‚çš„å€™é¸çƒå“¡
            candidates = player_data[player_data['Pos'].str.contains(position, na=False)]
            candidates = candidates[~candidates['Rk'].isin(seen)].sort_values('PTS', ascending=False)
            if not candidates.empty:
                replacement = candidates.iloc[0]  # å¾—åˆ†æœ€é«˜çš„å€™é¸äºº
                new_team.append(replacement['Rk'])
                seen.add(replacement['Rk'])
    return new_team

'''def print_player_scores():
    players_of_interest = ['Trae Young', 'Tyrese Haliburton']
    for player_name in players_of_interest:
        player_stats = player_data[player_data['Player'].str.contains(player_name, case=False)]
        if not player_stats.empty:
            player_id = player_stats.iloc[0]['Rk']
            score, _ = fitness_function([player_id])
            print(f"{player_name}: Fitness = {score:.2f}")
        else:
            print(f"{player_name}: Data not found")
'''
def log_missing_players(team):
    players_of_interest = ['Trae Young', 'Tyrese Haliburton', 'Anthony Davis']
    for player_name in players_of_interest:
        if player_name not in [player[0] for player in team]:
            print(f"Missing player: {player_name}")
def position_match(player_pos, target_pos):
    if not isinstance(player_pos, str):
        return False
    return target_pos in player_pos.split('-')

def local_search(team):
    # æ‰¾åˆ°çƒéšŠä¸­fitnessæœ€ä½çš„çƒå“¡
    lowest_score_index = -1
    lowest_score = float('inf')

    for i, player_id in enumerate(team):
        player_stats = player_data[player_data['Rk'] == player_id]
        if not player_stats.empty:
            player_stats = player_stats.iloc[0]
            # è¨ˆç®—Fitnessåˆ†æ•¸
            player_score = (
                player_stats['FGA'] * scoring_system['FGA'] +
                player_stats['FG'] * scoring_system['FG'] +
                player_stats['FTA'] * scoring_system['FTA'] +
                player_stats['FT'] * scoring_system['FT'] +
                player_stats['3P'] * scoring_system['3P'] +
                player_stats['PTS'] * scoring_system['PTS'] +
                player_stats['ORB'] * scoring_system['OREB'] +
                player_stats['DRB'] * scoring_system['DRB'] +
                player_stats['AST'] * scoring_system['AST'] +
                player_stats['STL'] * scoring_system['STL'] +
                player_stats['BLK'] * scoring_system['BLK'] +
                player_stats['TOV'] * scoring_system['TOV'] +
                player_stats['PF'] * scoring_system['PF']
            )
            if player_score < lowest_score:
                lowest_score = player_score
                lowest_score_index = i

    # æ›¿æ›fitnessæœ€ä½çš„çƒå“¡
    if lowest_score_index != -1:
        position = positions_required[lowest_score_index]

        # æ‰¾è©²ä½ç½®PTSå‰15åçƒå“¡
        all_candidates = player_data.copy()
        all_candidates = all_candidates[all_candidates['Pos'].apply(lambda p: position_match(p, position))]
        all_candidates = all_candidates.sort_values('PTS', ascending=False).head(15)

        if not all_candidates.empty:
            # åœ¨é€™15äººä¸­è¨ˆç®—Fitness
            all_candidates['Fitness_Score'] = (
                all_candidates['FGA'] * scoring_system['FGA'] +
                all_candidates['FG'] * scoring_system['FG'] +
                all_candidates['FTA'] * scoring_system['FTA'] +
                all_candidates['FT'] * scoring_system['FT'] +
                all_candidates['3P'] * scoring_system['3P'] +
                all_candidates['PTS'] * scoring_system['PTS'] +
                all_candidates['ORB'] * scoring_system['OREB'] +
                all_candidates['DRB'] * scoring_system['DRB'] +
                all_candidates['AST'] * scoring_system['AST'] +
                all_candidates['STL'] * scoring_system['STL'] +
                all_candidates['BLK'] * scoring_system['BLK'] +
                all_candidates['TOV'] * scoring_system['TOV'] +
                all_candidates['PF'] * scoring_system['PF']
            )

            # é¸Fitnessæœ€é«˜çš„äººæ›¿æ›
            best_candidate = all_candidates.sort_values('Fitness_Score', ascending=False).iloc[0]
            team[lowest_score_index] = best_candidate['Rk']

    return team


# çªè®Šæ“ä½œ
def mutate(team, mutation_rate=0.2):
    for i in range(len(team)):
        if random.random() < mutation_rate:
            position = positions_required[i]
            current_player_id = team[i]

            # åªè€ƒæ…®ç¬¦åˆç•¶å‰ä½ç½®éœ€æ±‚çš„çƒå“¡
            candidates = player_data[player_data['Pos'].str.contains(position, na=False)]
            candidates = candidates[~candidates['Rk'].isin(team)].sort_values('PTS', ascending=False)

            if not candidates.empty:
                # éš¨æ©Ÿé¸æ“‡å€™é¸çƒå“¡ï¼Œä½†ä¾ç…§åˆ†æ•¸æ’åº
                new_player = candidates.sample(n=1)['Rk'].values[0]
                team[i] = new_player

    return team
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

def analyze_results_ignore_order_with_plot(best_team, ideal_team):
    """
    åˆ†æç®—æ³•çµæœèˆ‡ç†æƒ³è§£çš„æº–ç¢ºæ€§ï¼Œä¸¦ç¹ªè£½æ··æ·†çŸ©é™£
    """
    # å°‡ `best_team` ä¸­çš„ `Rk` è½‰æ›ç‚ºçƒå“¡åç¨±
    best_team_names = set(
        player_data[player_data['Rk'].isin(best_team)]['Player'].str.strip().str.lower()
    )

    # å°‡ `ideal_team` è½‰æ›ç‚ºå°å¯«ï¼Œç¢ºä¿åç¨±æ ¼å¼ä¸€è‡´
    ideal_team_names = {name.strip().lower() for name in ideal_team}

    # è¨ˆç®— TP, FP, FN
    tp = len(best_team_names & ideal_team_names)  # æ­£ç¢ºé¸æ“‡çš„çƒå“¡
    fp = len(best_team_names - ideal_team_names)  # éŒ¯èª¤é¸æ“‡çš„çƒå“¡
    fn = len(ideal_team_names - best_team_names)  # æœªé¸åˆ°çš„æ­£ç¢ºçƒå“¡

    # æ‰“å°åˆ†æçµæœ
    print("=== åˆ†æçµæœ ===")
    print(f"True Positives (TP): {tp} - æ­£ç¢ºé¸æ“‡çš„çƒå“¡æ•¸é‡")
    print(f"False Positives (FP): {fp} - éŒ¯èª¤é¸æ“‡çš„çƒå“¡æ•¸é‡")
    print(f"False Negatives (FN): {fn} - æœªé¸åˆ°çš„æ­£ç¢ºçƒå“¡æ•¸é‡")

    # é¡¯ç¤ºè©³ç´°ä¿¡æ¯
    print("\n=== éŒ¯èª¤é¸æ“‡çš„çƒå“¡ ===")
    print(best_team_names - ideal_team_names)

    print("\n=== æœªé¸åˆ°çš„æ­£ç¢ºçƒå“¡ ===")
    print(ideal_team_names - best_team_names)

    # è¨ˆç®—æº–ç¢ºç‡å’Œå¬å›ç‡
    accuracy = tp / len(ideal_team_names) if len(ideal_team_names) > 0 else 0
    precision = tp / (tp + fp) if (tp + fp) > 0 else 0
    recall = tp / (tp + fn) if (tp + fn) > 0 else 0

    print("\n=== è©•ä¼°æŒ‡æ¨™ ===")
    print(f"Accuracy (æº–ç¢ºç‡): {accuracy:.2f}")
    print(f"Precision (ç²¾ç¢ºç‡): {precision:.2f}")
    print(f"Recall (å¬å›ç‡): {recall:.2f}")

    # æ··æ·†çŸ©é™£çš„æ§‹å»º
    y_true = [1 if name in ideal_team_names else 0 for name in player_data['Player'].str.strip().str.lower()]
    y_pred = [1 if name in best_team_names else 0 for name in player_data['Player'].str.strip().str.lower()]
    cm = confusion_matrix(y_true, y_pred, labels=[1, 0])

    # ç¹ªè£½æ··æ·†çŸ©é™£
    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=['Selected', 'Not Selected'])
    disp.plot(cmap='Blues')
    plt.title("Confusion Matrix")
    plt.show()

def mutate_elite(elite, mutation_rate=0.1):
    """
    å°ç²¾è‹±å€‹é«”é€²è¡Œå°å¹…è®Šç•°
    """
    new_elite = []
    for team in elite:
        if random.random() < mutation_rate:
            new_elite.append(mutate(team, mutation_rate=0.1))  # å°ç²¾è‹±å€‹é«”é€²è¡Œçªè®Š
        else:
            new_elite.append(team)
    return new_elite

def analyze_injury_impact(selected_players):
    print("\n=== å‚·ç—…å½±éŸ¿åˆ†æ ===")
    for player, adjusted_score, position, injury_impact, no_injury_score in selected_players:
        print(f"{player} ({position}): Adjusted Score = {adjusted_score:.2f}, No Injury Score = {no_injury_score:.2f}, Games Played Ratio = {injury_impact:.2%}")
    visualize_injury_impact(selected_players)



# éºå‚³ç®—æ³•ä¸»æµç¨‹
def genetic_algorithm():
    start_time = time.time()  # â±ï¸ é–‹å§‹è¨ˆæ™‚
    population = initialize_population()
    best_fitness_history = []

    for generation in range(150):  # å¢åŠ ä¸–ä»£æ•¸
        fitness_scores = []
        team_selections = []

        for team in population:
            score, selected_players = fitness_function(team)
            fitness_scores.append(score)
            team_selections.append(selected_players)

        # ä¿ç•™ç²¾è‹±
        elite_count = max(2, int(len(population) * 0.1))  # ä¿ç•™ 10% ç²¾è‹±
        elite_indices = sorted(range(len(fitness_scores)), key=lambda i: fitness_scores[i], reverse=True)[:elite_count]
        elites = [population[i] for i in elite_indices]  # ä¿ç•™ç²¾è‹±å€‹é«”
        elites = mutate_elite(elites)  # å°ç²¾è‹±é€²è¡Œå°å¹…è®Šç•°

        # è¨ˆç®—å¤šæ¨£æ€§
        diversity = np.std(fitness_scores)
        print(f"Generation {generation + 1}: Population Diversity = {diversity}")

        # é‡æ–°åˆå§‹åŒ–éƒ¨åˆ†ç¨®ç¾¤ï¼ˆé¿å…æ—©ç†Ÿæ”¶æ–‚ï¼‰
        if diversity < 1e-3:  # å¦‚æœå¤šæ¨£æ€§éä½
            for i in range(len(population) // 10):  # æ›¿æ› 10% ç¨®ç¾¤
                population[i] = initialize_population()[0]

        # ç•¶å‰ä¸–ä»£æœ€ä½³è§£
        best_index = fitness_scores.index(max(fitness_scores))
        best_team = population[best_index]
        best_fitness = fitness_scores[best_index]
        best_fitness_history.append(best_fitness)

        print(f"Generation {generation + 1}: Best Fitness = {best_fitness}")
        for player, score, position, injury_impact, no_injury_score in team_selections[best_index]:
            print(f"  {player} ({position}): Adjusted Score = {score:.2f}, No Injury Score = {no_injury_score:.2f}, Games Played Ratio = {injury_impact:.2%}")

        # æå‰åœæ­¢æ¢ä»¶ï¼šæª¢æŸ¥æ˜¯å¦æ»¿è¶³ç›®æ¨™çƒå“¡çµ„åˆ

        # æå‰åœæ­¢æ¢ä»¶ï¼šæª¢æŸ¥æ˜¯å¦æ»¿è¶³ç›®æ¨™çƒå“¡çµ„åˆ
        best_team_names = set(
            player_data[player_data['Rk'].isin(best_team)]['Player'].str.strip().str.lower()
        )
        if target_players.issubset(best_team_names):
            print(f"Target team found at generation {generation + 1} with fitness {best_fitness}. Stopping early.")
            break  # æå‰çµæŸå¾ªç’°

        # é¸æ“‡ä¸‹ä¸€ä»£
        next_generation = elites.copy()
        for _ in range((len(population) - elite_count) // 2):
            parent1 = random.choices(population, weights=fitness_scores, k=1)[0]
            parent2 = random.choices(population, weights=fitness_scores, k=1)[0]
            child1, child2 = crossover(parent1, parent2)
            child1 = mutate(child1)
            child2 = mutate(child2)
            child1 = local_search(child1)
            child2 = local_search(child2)
            # æª¢æŸ¥å­ä»£æ˜¯å¦å„ªæ–¼çˆ¶ä»£
            if fitness_function(child1)[0] < fitness_function(parent1)[0]:
                child1 = parent1
            if fitness_function(child2)[0] < fitness_function(parent2)[0]:
                child2 = parent2

            # æ·»åŠ åˆ°ä¸‹ä¸€ä»£
            next_generation.extend([child1, child2])

        population = next_generation
    end_time = time.time()  # â±ï¸ çµæŸè¨ˆæ™‚
    total_time = end_time - start_time
    print(f"â±ï¸ Total execution time: {total_time:.2f} seconds")

    

    return best_team, best_fitness, total_time, generation + 1,best_fitness_history
# å¤šè¼ªå¯¦é©—æ”¾åœ¨å¤–é¢ï¼
num_runs = 5
total_time = 0
total_generations = 0
all_histories = []
for run in range(num_runs):
    print(f"\nğŸ” Run {run + 1}")
    fitness_cache.clear()
    best_team, best_fitness, exec_time, generations,best_fitness_history = genetic_algorithm()
    total_time += exec_time
    total_generations += generations
    all_histories.append(best_fitness_history) 
avg_time = total_time / num_runs
avg_generations = total_generations / num_runs

print(f"\nâœ… Average over {num_runs} runs:")
print(f"â±ï¸ Average Time: {avg_time:.2f} seconds")
print(f"ğŸ“ˆ Average Generations: {avg_generations:.2f}")
# ç†æƒ³è§£
ideal_team = [
    "james harden", "shai gilgeous-alexander", "anthony edwards", "trae young",
    "cade cunningham","jayson tatum", "giannis antetokounmpo", "karl-anthony towns",
    "lebron james","nikola jokic" 
]

# åŸ·è¡Œéºå‚³ç®—æ³•å‰æ¸…ç©ºå¿«å–
fitness_cache.clear()  # ç¢ºä¿æ¯æ¬¡å¯¦é©—é–‹å§‹æ™‚æ²’æœ‰èˆŠçš„è³‡æ–™å¹²æ“¾
np.save('normal_this_end.npy', np.array(best_fitness_history))
'''# åŸ·è¡Œéºå‚³ç®—æ³•
best_team, best_fitness, exec_time, generations = genetic_algorithm()
# å°æœ€ä½³çƒéšŠé‡æ–°è¨ˆç®—é©æ‡‰åº¦ä»¥ç²å–å®Œæ•´æ•¸æ“š'''
_, selected_players = fitness_function(best_team)
# ç¹ªè£½æ”¶æ–‚æ›²ç·š
plt.plot(range(len(best_fitness_history)), best_fitness_history, marker='o')
plt.title("Convergence Curve")
plt.xlabel("Generations")
plt.ylabel("Best Fitness")
plt.grid(True)
plt.show()
# å°çµæœé€²è¡Œåˆ†æä¸¦ç¹ªè£½æ··æ·†çŸ©é™£
analyze_results_ignore_order_with_plot(best_team, ideal_team)
analyze_injury_impact(selected_players)

